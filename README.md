# Multi Data-Source Spring Application

This is a sample application developed with the goal of elaborating the method of configuring a Spring Boot application to have the cabpability to have multiple data sources. This application was generated using [JHipster 6.10.5](https://www.jhipster.tech/) as a `microservice` application. Only the bare minimum for are included, which are dependencies for Spring Data primarily. Other features (authentication, second level hibernate cache, service discovery, etc.) are removed from the project for simplicity sake.

## Requirements

* [JDK 11](https://adoptopenjdk.net/)
* [PostgreSQL 13](https://www.postgresql.org/)
* [Maven](https://maven.apache.org/)

## Prerequisites
Before running the application ensure that:
1. Databases are created. The script to create the required schemas can be found in the `database` directory.
2. The properties within `app.yml` or `app-dev.yml` (in the `resource\main\resources\config` directory are updated. For example, database url, username, password and any other required properties.

## Running the App
To run the app, use the following command from the command line:
##### Windows
```batch
mvnw
```
##### Linux
```bash
./mvnw
```

## Explanation

The project structure follows a standard Spring Boot Application structure with some additions which are specific to JHipster. Some components generated by JHipster, such as authentication, `User` and `Authorization` related, are removed for simplicity sake. However the fundamental concepts of configuration are the main discussion of this project.

Basically, there are two data sources which are two PostgreSQL databases named `alpha_db` and `beta_db`, each containing `alpha_schema` and `beta_schema` schemas respectively. All `alpha_db` and `beta_db` related components or variables within the code are prefixed with `alpha` and `beta` respectively.

The underlying principle to achieve the desired outcome is to segregate entites and other persistence related components into separate packages (or directories) and specifying the packages in the corresponding configuration bean.

### Domain

Firstly the domain objects will be segregated into seperate directories based on the data source they correspond with. In this case, `AlphaObject` will reside in `alpha` package (in `domain`) and the same applies to `BetaObject`. Hence there are two separate packages containing entity objects: `io.damelyngdoh.multidatasourcespringapp.domain.alpha` and `io.damelyngdoh.multidatasourcespringapp.domain.beta`.

### JPA Repository

The same segregation policy is carried out for JPA repository proxy interfaces resulting to separate packages `io.damelyngdoh.multidatasourcespringapp.repository.alpha` and `io.damelyngdoh.multidatasourcespringapp.repository.beta`.

### Application Properties

The application properties are specified in the `app.yml` as well as in the `app-dev.yml` (similar properties specified in `app-dev.yml` will overwrite those in `app.yml`). Most of the properties are generated by JHipster and will not be used or elaborated in this project.

The properties to consider are under `persistence-config` prefix. The `common-jpa` properties are the common JPA properties for both data sources and the `common-datasource` properties are the common datasource properties for both the data sources. The properties within these will be referenced by the properties under `alpha` (`persistence-config.alpha`) and `beta` (`persistence-config.beta`). Keeping common properties this way makes it easier during changes where the need to update common properties multiple times (redundantly) is avoided.
```yaml
persistence-config:
	common-jpa:
		open-in-view: false
		database-platform: io.github.jhipster.domain.util.FixedPostgreSQL10Dialect
		show-sql: true
		properties:
			hibernate.jdbc.time_zone: UTC
			hibernate.id.new_generator_mappings: true
			hibernate.connection.provider_disables_autocommit: true
			hibernate.cache.use_second_level_cache: false
			hibernate.cache.use_query_cache: false
			hibernate.generate_statistics: false
			hibernate.connection.autocommit: false
			# modify batch size as necessary
			hibernate.jdbc.batch_size: 25
			hibernate.order_inserts: true
			hibernate.order_updates: true
			hibernate.query.fail_on_pagination_over_collection_fetch: true
			hibernate.query.in_clause_parameter_padding: true
		hibernate:
			ddl-auto: none
			naming:
				physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
				implicit-strategy: org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy

	common-datasource:
		type: com.zaxxer.hikari.HikariDataSource
		username: postgres
		password: consortium
		hikari:
			poolName: Hikari
			auto-commit: false
```

Intuitively, in this case only the schema (`jpa.properties.hibernate.default_schema`) and datasource url (`datasource.url`) properties will be different for the two data sources.

### Configuration

Finally, we create the configuration beans which will wire the entities to the corresponding datasources. There are two configuration objects (both annotated with [`@Configuration`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html)) `AlphaDataSourceConfiguration` and `BetaDataSourceConfiguration`. In this case since both the datasources are similar, i.e. both are of the same database type, hence the configuration properties and beans will also be structurally similar and the only differences will be references to the packages and bean names. 

However, it may also be the case the requirements specify the use multiple databases of different types (say MySQL and SQLite). In such a scenario the configuration files or beans may look different but the underlying principle will be similar.

Spring requires that we must provide a `DataSource`, `EntityManagerFactory` (where an `EntityManager` will be required so hence the entity manager factory) and `TransactionManager` bean. The different types of beans that will be created by the configuration are:

#### DataSourceProperties

This bean will contain the properties for the datasource which will be read automatically from the application properties. The [`@ConfigurationProperties`](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/ConfigurationProperties.html) annotation enusures that the values are read from the appropriate properties via the prefix parameter. Additional properties may be specified for this bean before returning it.
Note that, all the `@Bean` annotation have been specified a bean name. This is to ensure that there are no conflicts that may arise when passing the beans as parameters.
[`DataSourceProperties` documentation](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.html)
```java
@Primary
@Bean(name = "alphaDataSourceProperties")
@ConfigurationProperties(prefix = "persistence-config.alpha.datasource")
public  DataSourceProperties  getAlphaDataSourceProperties() {
	return  new  DataSourceProperties();
}
```

#### DataSource

The `DataSourceProperties` bean will be passed to the method to generate the `DataSource` bean so as to generate the `DataSource` object with the appropriate properties. The parameter passed to the method is annotated with `@Qualifier` which specifies the name of the appropriate `DataSourceProperties` bean.
```java
@Primary
@Bean(name = "alphaDataSource")
public  DataSource  getAlphaDataSource(
final @Qualifier("alphaDataSourceProperties") DataSourceProperties  dataSourceProperties
) {
	HikariDataSource  dataSource = dataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
	dataSource.setAutoCommit(false);
	return  dataSource;
}
```

#### JpaProperties

Analogous to the `DataSourceProperties` bean this bean will contain the properties which will be read from the application properties file and from the appropriate prefix specified by the `@ConfigurationProperties` annotation.
[`JpaProperties` documentation](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/orm/jpa/JpaProperties.htmll)
```java
@Primary
@Bean("alphaJpaProperties")
@ConfigurationProperties(prefix = "persistence-config.alpha.jpa")
public  JpaProperties  alphaJpaProperties() {
	return  new  JpaProperties();
}
```

#### EntityManagerFactory

An `EntityManager` will be required by Spring to perform persistence operations on entities ([Link for more information](https://docs.jboss.org/hibernate/entitymanager/3.6/reference/en/html_single/#:~:text=The%20EntityManager%20API%20is%20used,to%20the%20Session%20in%20Hibernate.)), ergo, an `EntityManagerFactory` will be required. 
```java
@Primary
@Bean("alphaEntityManagerFactory")
public  LocalContainerEntityManagerFactoryBean  getAlphaEntityManagerFactory(
	final @Qualifier("alphaDataSource") DataSource  dataSource,
	final @Qualifier("alphaJpaProperties") JpaProperties  jpaProperties
) {
	// Configuring Hibernate Jpa Vendor Adapter
	HibernateJpaVendorAdapter  jpaVendorAdapter = new  HibernateJpaVendorAdapter();
	jpaVendorAdapter.setDatabase(Database.POSTGRESQL);
	jpaVendorAdapter.setDatabasePlatform(jpaProperties.getDatabasePlatform());
	jpaVendorAdapter.setGenerateDdl(jpaProperties.isGenerateDdl());
	jpaVendorAdapter.setShowSql(jpaProperties.isShowSql());

	// Configuring Entity Manager Factory
	LocalContainerEntityManagerFactoryBean  emf = new  LocalContainerEntityManagerFactoryBean();
	emf.setDataSource(dataSource);
	emf.setJpaPropertyMap(jpaProperties.getProperties());
	emf.setJpaVendorAdapter(jpaVendorAdapter);
	emf.setPackagesToScan("io.damelyngdoh.multidatasourcespringapp.domain.alpha");
	emf.setPersistenceUnitName(Constants.ALPHA_PERSISTENCE_UNIT);
	emf.afterPropertiesSet();
	log.debug("EMF Complete.");
	return  emf;
}
```
A JPA vendor adapter needs to be instantiated because we are using Hibernate in this case as the JPA provider.

`jpaVendorAdapter.setDatabase(Database.POSTGRESQL)` this statement specifies that the database we are using is PostgreSQL.

`emf.setPackagesToScan("io.damelyngdoh.multidatasourcespringapp.domain.alpha")` statement specifies the package(s) which contains the entities for the datasource.

`emf.setPersistenceUnitName(Constants.ALPHA_PERSISTENCE_UNIT)` this statement takes a value from the `Constants` object which is a container for global static values, and sets the persistence unit name. This is important in case there is a need to get an `EntityManager` bean or other beans from the specific persistence context. As an example the `AlphaObjectService` (also refer to its implementation) contains an additional method to get a list of all `AlphaObjects` using the `EntityManager`. The `EntityManager` bean is retrieved using the `@PersistenceContext` annotation with the specific persistence unit name as a parameter. So it is a good practice to specify bean names if there are several beans of the same type.

#### TransactionManager

Lastly a `TransactionManager` bean is generated as `JpaTransactionManager` using the `EntityManagerFactory` and `JpaProperties` beans passed as paramters and specified by the qualifier.

The reason for why `JpaTransactionManager` is used instead of `HibernateTransactionManager` can be made clear in this [link](https://stackoverflow.com/questions/12337504/hibernatetransactionmanager-or-jpatransactionmanager). However, this is not  mandatory and depends on the project requirements.
```java
@Primary
@Bean(name = "alphaTransactionManager")
public  JpaTransactionManager  getAlphaTransactionManager(
	final @Qualifier("alphaEntityManagerFactory") EntityManagerFactory  entityManagerFactory,
	final @Qualifier("alphaJpaProperties") JpaProperties  jpaProperties
) {
	JpaTransactionManager  jpaTransactionManager = new  JpaTransactionManager(entityManagerFactory);
	jpaTransactionManager.setPersistenceUnitName(Constants.ALPHA_PERSISTENCE_UNIT);
	jpaTransactionManager.setJpaPropertyMap(jpaProperties.getProperties());
	return  jpaTransactionManager;
}
```

Note that `@Primary` annotation is specified to the methods in `AlphaDataSourceConfiguration` and not `BetaDataSourceConfiguration`. This is because the annotation specifies that the bean generated will be the default in case no bean name is specified in a qualifier. The annotation must not be attached to multiple methods of the same type as tSpring will generate an exception.

The code snippets above are taken from alpha data source configuration but the same applies to the beta data source configuration as well with changes that are self-explanatory.

The configuration beans are also annotated with `@EnableJpaRepositories` where the base packages of the repositories, the bean name of the entity manager factory and transaction manager is specified. This also highlights the need to name the beans.

### Srevices

The services are self-explanatory and uses instances of the repositories to persist the entities. The `AlphaObjectService` contains an additional method that gets the list of all `AlphaObject` in the database using `EntityManager`. This was done to emphasize the usage of persistence unit name and could have also been accomplisehd using the repository interface.

### REST API
The REST API to use to view the results are:
* `http://localhost:6050/api/alpha`] - gets a random `AlphaObject`
* `http://localhost:6050/api/alpha/entitymanager` - gets all `AlphaObject` in the database.
* `http://localhost:6050/api/beta` - gets a random `BetaObject`.

## Notes

Although there are Liquibase configurations, the beans specified will be similar and in this project that is not emphasized but it should be intuitive.

## References
* [Using Custom/Multiple Entity Managers](https://docs.spring.io/spring-boot/docs/2.1.11.RELEASE/reference/html/howto-data-access.html#howto-use-custom-entity-manager)
* [Sample Code](https://stackoverflow.com/questions/45663025/spring-data-jpa-multiple-enablejparepositories)
* [Sample Code from Spring](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-two-datasources)